<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>{{ title or "TinySpark" }}</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}" />
  </head>
  <body>
    <div class="header-section">
      <div class="header-content">
        <h1 style="color: white; margin: 0; font-size: 1.75rem; font-weight: 700;">TinySpark Story Starter</h1>
        <p class="header-subtitle">Generate creative images to inspire young writers aged 6-11</p>
      </div>
    </div>
    <main class="container">
      <div class="main-content">

      <div class="button-container">
        <button id="generateBtn" class="kid-button">Generate Story</button>
        <span id="status" class="status-text">Ready</span>
      </div>

      <div id="promptBox" class="prompt-box" style="display:none;"></div>

      <div class="content-wrapper">
        <div class="image-container">
          <img id="image" alt="Story inspiration image" style="display:none;" />
          <p id="placeholder" class="placeholder-text">
            Your generated image will appear here
          </p>
        </div>

        <section class="tips-section">
          <h3>Story Writing Guide</h3>
          <ul>
            <li>Who are the characters in your story?</li>
            <li>Where does your story take place?</li>
            <li>What problem or adventure do they face?</li>
            <li>How do they solve it or what happens next?</li>
          </ul>
        </section>
      </div>
      </div>
    </main>

    <!-- Loading overlay for new image generation -->
    <div id="loadingOverlay" class="loading-overlay">
      <div class="loading-content">
        <h2 class="loading-title">Creating Your Story Image!</h2>
        <div class="loading-spinner">
          <div class="spinner-ring"></div>
          <div class="spinner-ring"></div>
          <div class="spinner-ring"></div>
        </div>
        <p class="loading-message">
          <span class="loading-emoji">ðŸŽ¨</span>
          Our artists are working hard!
          <span class="loading-emoji">âœ¨</span>
        </p>
        <p class="loading-subtitle" id="loadingSubtitle">
          This might take a moment...
        </p>
      </div>
    </div>

    <script>
      const btn = document.getElementById('generateBtn');
      const img = document.getElementById('image');
      const statusEl = document.getElementById('status');
      const promptBox = document.getElementById('promptBox');
      const placeholder = document.getElementById('placeholder');
      const loadingOverlay = document.getElementById('loadingOverlay');
      const loadingSubtitle = document.getElementById('loadingSubtitle');
      
      let allImages = [];
      let currentImageIndex = 0;
      let subtitleInterval = null;
      let rouletteTimeout = null;
      let preloadedImages = new Map();

      const funMessages = [
        "Mixing colors and magic...",
        "Drawing your amazing story...",
        "Almost there, just a bit more...",
        "Creating something special...",
        "Your story is coming to life!",
        "Adding the finishing touches...",
      ];

      function showLoadingOverlay() {
        loadingOverlay.classList.add('active');
        let messageIndex = 0;
        
        // Rotate through fun messages every 4 seconds
        subtitleInterval = setInterval(() => {
          loadingSubtitle.textContent = funMessages[messageIndex];
          messageIndex = (messageIndex + 1) % funMessages.length;
        }, 4000);
      }

      function hideLoadingOverlay() {
        loadingOverlay.classList.remove('active');
        if (subtitleInterval) {
          clearInterval(subtitleInterval);
          subtitleInterval = null;
        }
      }

      async function loadAllImages() {
        try {
          const res = await fetch('/api/existing-images');
          if (res.ok) {
            const data = await res.json();
            allImages = data.images || [];
            console.log('Loaded', allImages.length, 'images');
            // Shuffle the array for random order
            for (let i = allImages.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              [allImages[i], allImages[j]] = [allImages[j], allImages[i]];
            }
            // Preload all images for smooth roulette effect
            preloadImages();
          }
        } catch (e) {
          console.error('Failed to load images:', e);
        }
      }

      function preloadImages() {
        allImages.forEach((imageData, index) => {
          const img = new Image();
          img.src = imageData.url;
          preloadedImages.set(imageData.url, img);
        });
      }

      function showRouletteEffect(targetIndex, onComplete) {
        if (allImages.length === 0) {
          if (onComplete) onComplete();
          return;
        }

        let currentCycleIndex = 0;
        let delay = 50; // Start fast (50ms)
        const minDelay = 300; // Slow down to 300ms
        const delayIncrement = 15; // Gradually increase delay
        const minCycles = 3; // Minimum number of full cycles
        const totalCycles = minCycles + Math.floor(Math.random() * 2); // 3-4 full cycles
        let cyclesCompleted = 0;
        let isSlowing = false;
        const maxDuration = 5000; // Maximum 5 seconds
        const startTime = Date.now();
        let animationComplete = false;

        // Calculate how many images to cycle through
        const totalImages = allImages.length;
        const totalSteps = totalCycles * totalImages + targetIndex;

        function stopOnTarget() {
          if (animationComplete) return;
          animationComplete = true;
          
          // Clear any pending timeout
          if (rouletteTimeout) {
            clearTimeout(rouletteTimeout);
            rouletteTimeout = null;
          }
          
          // Stop on target image
          const targetImage = allImages[targetIndex];
          img.src = targetImage.url;
          img.classList.remove('roulette-spinning');
          img.style.display = 'block';
          placeholder.style.display = 'none';
          promptBox.textContent = 'Story prompt: ' + targetImage.prompt;
          promptBox.style.display = 'block';
          statusEl.textContent = '';
          btn.disabled = false;
          if (onComplete) onComplete();
        }

        // Set maximum duration timeout
        const maxDurationTimeout = setTimeout(() => {
          stopOnTarget();
        }, maxDuration);

        function cycleImage() {
          // Check if 5 seconds have passed
          const elapsed = Date.now() - startTime;
          if (elapsed >= maxDuration) {
            clearTimeout(maxDurationTimeout);
            stopOnTarget();
            return;
          }

          if (currentCycleIndex >= totalSteps) {
            clearTimeout(maxDurationTimeout);
            stopOnTarget();
            return;
          }

          // Show current image in cycle
          const displayIndex = currentCycleIndex % totalImages;
          const currentImage = allImages[displayIndex];
          
          img.src = currentImage.url;
          img.style.display = 'block';
          img.classList.add('roulette-spinning');
          placeholder.style.display = 'none';
          promptBox.textContent = 'Story prompt: ' + currentImage.prompt;
          promptBox.style.display = 'block';

          currentCycleIndex++;

          // Check if we've completed a full cycle
          if (displayIndex === totalImages - 1) {
            cyclesCompleted++;
            // Start slowing down after minimum cycles
            if (cyclesCompleted >= minCycles && !isSlowing) {
              isSlowing = true;
            }
          }

          // Gradually slow down
          if (isSlowing && delay < minDelay) {
            delay = Math.min(delay + delayIncrement, minDelay);
          }

          rouletteTimeout = setTimeout(cycleImage, delay);
        }

        // Start the roulette effect
        statusEl.textContent = 'Spinning...';
        cycleImage();
      }

      async function getRandomImage() {
        try {
          // Clear any existing roulette timeout
          if (rouletteTimeout) {
            clearTimeout(rouletteTimeout);
            rouletteTimeout = null;
          }

          // Load all images if we haven't yet
          if (allImages.length === 0) {
            await loadAllImages();
          }
          
          btn.disabled = true;
          img.style.display = 'none';
          placeholder.style.display = 'block';
          promptBox.style.display = 'none';
          
          // Debug logging
          console.log('Current index:', currentImageIndex, 'Total images:', allImages.length);
          
          // Check if we've shown all existing images
          // After showing all images, the next click (5th if 4 images exist) generates new
          // We check BEFORE incrementing, so if index equals length, we've shown all
          const allImagesShown = allImages.length > 0 && currentImageIndex >= allImages.length;
          const generateNew = allImagesShown || allImages.length === 0;
          
          console.log('All images shown?', allImagesShown, 'Generate new?', generateNew, 'Condition:', currentImageIndex, '>=', allImages.length);
          
          if (generateNew) {
            // Generate new image with OpenAI (5th click after showing all existing)
            console.log('Generating new image via OpenAI');
            showLoadingOverlay();
            statusEl.textContent = 'Generating new image...';
            
            const res = await fetch('/api/random-image', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({ generate_new: true }),
            });
            
            if (!res.ok) throw new Error('Request failed');
            
            const data = await res.json();
            promptBox.textContent = 'Story prompt: ' + data.prompt;
            promptBox.style.display = 'block';
            
            img.src = data.image_url;
            img.onload = () => { 
              img.style.display = 'block';
              placeholder.style.display = 'none';
              hideLoadingOverlay();
              
              // Reset index and reload images to include the new one
              currentImageIndex = 0;
              console.log('Reset index to 0, reloading images');
              loadAllImages().then(() => {
                btn.disabled = false;
              });
            };
            
            statusEl.textContent = '';
          } else {
            // Use roulette effect for existing images (1st-4th clicks)
            if (allImages.length > 0 && currentImageIndex < allImages.length) {
              const imageIndexToShow = currentImageIndex;
              console.log('Showing existing image at index:', imageIndexToShow, 'out of', allImages.length);
              showRouletteEffect(imageIndexToShow, () => {
                // Increment index only after roulette completes
                currentImageIndex++;
                console.log('Roulette complete, index incremented to:', currentImageIndex, 'out of', allImages.length);
              });
            } else {
              // Edge case: should not happen, but generate new if it does
              console.log('Edge case: allImages.length =', allImages.length, 'currentImageIndex =', currentImageIndex);
              showLoadingOverlay();
              statusEl.textContent = 'Generating new image...';
              
              const res = await fetch('/api/random-image', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({ generate_new: true }),
              });
              
              if (!res.ok) throw new Error('Request failed');
              
              const data = await res.json();
              promptBox.textContent = 'Story prompt: ' + data.prompt;
              promptBox.style.display = 'block';
              
              img.src = data.image_url;
              img.onload = () => { 
                img.style.display = 'block';
                placeholder.style.display = 'none';
                hideLoadingOverlay();
                currentImageIndex = 0;
                loadAllImages().then(() => {
                  btn.disabled = false;
                });
              };
              
              statusEl.textContent = '';
            }
          }
        } catch (e) {
          statusEl.textContent = 'Error - please try again';
          placeholder.style.display = 'block';
          hideLoadingOverlay();
          btn.disabled = false;
        }
      }

      // Load images on page load
      loadAllImages();

      btn.addEventListener('click', getRandomImage);
    </script>
  </body>
  </html>


